# 《编译系统原理》总结

## 第一章 介绍

词法分析中，分词不仅仅是直接分割为子串，还进行了分类。

浏览器是一个广义的编译器。浏览器渲染的过程中是代码生成。

- 抽象语法树：只包含单词
- 具体语法树：包含语法概念

数据库查询也是广义的编译器。



编译器的两个基本组成部分：

- 分析：将源程序分解为基本的组成部分，生成中间表达形式
- 生成：从中间表达形式构建目标程序



格式化打印、格式化编辑器、LATEX、数据压缩等都是编译器。



- 解释器：就是类似于英文中文的翻译，**特点是不产生目标程序，是边分析边执行的。**
  - 举例：翻译，BASIC，Bash，Java，Python
- 编译器：有上下文联系必须编译整个代码



代码优化在前端后端都有。



各阶段干了啥：

- 词法分析：扫描，忽略空格回车等，将字符组成为单词
- 语法分析：生成抽象语法树，将产生的单词组合为语法短语
  - 词法分析不需要递归，语法分析需要
- 语义分析：自底向上
- 中间代码生成：生成llvm语言
- 代码优化：优化代码，分前端后端
- 代码生成：生成可重定位的机器码或者汇编码。确定了变量的内存位置，为变量指定寄存器



符号表：记录了程序的标识符，类型，作用域。**在词法分析时创建**



各阶段错误：

- 词法分析：字符无法构成单词
- 语法分析：单词流违反了语法结构规则
- 语义分析：语法结构正确，但是没有实际意义



所在阶段：涉及到编程语言都是前端，涉及到体系结构都是后端，中端为代码优化



**预处理器（不属于编译器的步骤）：**

- 宏定义 #define
- \#include
- Rational预处理器——是一个举例
- 语言扩展（预处理器的一个功能）

**汇编器：由汇编器生成可重定位机器码：**

两次扫描汇编：

- 第一次：识别标识符，存入符号表，指定相对内存地址。
- 第二次：产生可重定位机器码。



**代码加载**就是从相对地址到绝对地址的修改。

**连接器：**将多个可重定位机器码文件组合成为单一程序。



- 前端：词法分析 语法分析 语义分析 错误处理 中间代码生成 部分中间代码优化 
- 后端：部分中间代码优化 代码生成



**扫描：**多个阶段（词法分析到中间代码生成）合成一次扫描，中间结果全部保存在内存。



## 第三章 词法分析

**设计题**

- 正则表达式描述单词
  - <img src=".\pic\image-20250105085634131.png" alt="image-20250105085634131" style="zoom: 67%;" />
- 有限自动机识别单词
  - <img src=".\pic\image-20250105085757447.png" alt="image-20250105085757447" style="zoom:50%;" />
  - <img src=".\pic\image-20250105085824469.png" alt="image-20250105085824469" style="zoom:50%;" />

**计算大题**

- 正则表达式转NFA——汤普森构造法
  - <img src=".\pic\image-20250105085859967.png" alt="image-20250105085859967" style="zoom:50%;" />
  - <img src=".\pic\image-20250105085918685.png" alt="image-20250105085918685" style="zoom:50%;" />
  - <img src=".\pic\image-20250105085940020.png" alt="image-20250105085940020" style="zoom:50%;" />
  - <img src=".\pic\image-20250105090000256.png" alt="image-20250105090000256" style="zoom:50%;" />
- NFA转DFA——子集构造法
  - <img src=".\pic\image-20250105090127820.png" alt="image-20250105090127820" style="zoom:50%;" />
- DFA最小化——状态划分
  - <img src=".\pic\image-20250105090222396.png" alt="image-20250105090222396" style="zoom:50%;" />





## 第四章 语法分析

### NFA转CFG

<img src=".\pic\image-20250105090434773.png" alt="image-20250105090434773" style="zoom:50%;" />

### 消除左递归

<img src=".\pic\image-20250105090601967.png" alt="image-20250105090601967" style="zoom:50%;" />

<img src=".\pic\image-20250105090616776.png" alt="image-20250105090616776" style="zoom:50%;" />

### 消除$\varepsilon$产生式

<img src=".\pic\image-20250105090740673.png" alt="image-20250105090740673" style="zoom:50%;" />

### 消除回路

<img src=".\pic\image-20250105090807097.png" alt="image-20250105090807097" style="zoom:50%;" />

### 提取左公因子

<img src=".\pic\image-20250105090844463.png" alt="image-20250105090844463" style="zoom:50%;" />

### 非递归预测分析——LL(1)文法

- 先预处理，消除左递归和提取左公因子
- 求出FIRST集和FOLLOW集
  - FIRST
    - <img src=".\pic\image-20250105091247030.png" alt="image-20250105091247030" style="zoom:50%;" />
  - FOLLOW
    - <img src=".\pic\image-20250105091309625.png" alt="image-20250105091309625" style="zoom:50%;" />
- 填表，FIRST直接填，FOLLOW的话就是如果FIRST中出现了空符号的话，就将FOLLOW集写入
  - <img src=".\pic\image-20250105091137653.png" alt="image-20250105091137653" style="zoom:50%;" />
- 根据填好的表来进行字符串的入栈分析
  - <img src=".\pic\image-20250105091210551.png" alt="image-20250105091210551" style="zoom:50%;" />

LL(1)文法的特性：

<img src=".\pic\image-20250105091355876.png" alt="image-20250105091355876" style="zoom:50%;" />

### 算符优先算法

特点：

- 无$\varepsilon$产生式
- 产生式右部不含连续的NT

<img src=".\pic\image-20250105092358569.png" alt="image-20250105092358569" style="zoom:50%;" />

算法：

<img src=".\pic\image-20250105092416744.png" alt="image-20250105092416744" style="zoom:50%;" />

得到算符优先表之后，我们就可以开始进行字符串的分析了。

<img src=".\pic\image-20250105092504814.png" alt="image-20250105092504814" style="zoom:50%;" />



### LR(0)构造DFA

先转拓广文法

![image-20250105094718112](.\pic\image-20250105094718112.png)

就是构造一个项目规范簇（求闭包别忘了）

![image-20250105094702796](.\pic\image-20250105094702796.png)

根据上面的项目簇得到两个表

![image-20250105094746979](.\pic\image-20250105094746979.png)



### LR(0)构造NFA

> 2019-2020学年A卷第四大题

还是和前面的构造方法差不多，就是只需要写一条转换了

<img src=".\pic\image-20250105115552243.png" alt="image-20250105115552243" style="zoom:50%;" />

解答：

<img src=".\pic\image-20250105115619740.png" alt="image-20250105115619740" style="zoom: 67%;" />

PPT方法：

![image-20250105120242055](.\pic\image-20250105120242055.png)

![image-20250105120301595](.\pic\image-20250105120301595.png)

![image-20250105120326310](.\pic\image-20250105120326310.png)



### SLR(1)

在LR(0)的基础上多求了一步FOLLOW集，也就是对于整行都是规约的项目，只在其FOLLOW集上写规约

<img src=".\pic\image-20250105094910107.png" alt="image-20250105094910107" style="zoom: 67%;" />



### LR(1)

在LR(0)的基础上增加了一个向前搜索符

![image-20250105095014118](.\pic\image-20250105095014118.png)

就是，先看前面，如果是开始符的话，就直接写$，如果是非终结符的话，对应到右边去看，写入所有的点后面是该非终结符的向前搜索符，如果是非终结符后面是空的，就照抄，如果是终结符，就把终结符写进去，如果是非终结符，就写入其FIRST集



然后其他部分是一样的

![image-20250105095040624](.\pic\image-20250105095040624.png)

得到两个表：

<img src=".\pic\image-20250105095059169.png" alt="image-20250105095059169" style="zoom: 67%;" />



### LALR(1)

在LR(1)的基础上，完成了合并同心集的运算，也就是将表达式相同，但是向前搜索符不同的状态进行了合并

<img src=".\pic\image-20250105095200571.png" alt="image-20250105095200571" style="zoom:67%;" />

得到两个表：

![image-20250105095221287](.\pic\image-20250105095221287.png)

### LR分析如何处理字符串

分为三个，先得知道怎么用得到的ACTION表和GOTO表处理字符串

<img src=".\pic\image-20250105093210580.png" alt="image-20250105093210580" style="zoom:50%;" />

<img src=".\pic\image-20250105093226814.png" alt="image-20250105093226814" style="zoom:50%;" />

运行方式：

<img src=".\pic\image-20250105093250841.png" alt="image-20250105093250841" style="zoom:50%;" />

字符串处理方式：

根据计算出的两个表：

<img src=".\pic\image-20250105093611495.png" alt="image-20250105093611495" style="zoom:50%;" />

来进行字符串的移进与规约

<img src=".\pic\image-20250105093638638.png" alt="image-20250105093638638" style="zoom:50%;" />



### 如何区分LR分析算法

LR(0)文法：不存在冲突项目，也就是移进-规约，规约-规约

如果存在冲突的话，我们就要使用SLR(1)文法了

SLR(1)文法如果存在冲突，就用FOLLOW集来判断，如果为空的话，就说明可以用SLR(1)

如果不为空的话，就说明不能使用

然后使用LR(1)看看

根据向前搜索符去判断，如果搜索符为空的话，就说明是LR(1)文法

如果不为空的话，就说明无法构表

然后尝试LALR文法，合并同心集，就可以了

**注意，任何一个SLR文法都是LALR文法**





## 第五章 语法制导翻译

- 综合属性、继承属性
- S－属性定义
  - 仅综合属性
- L－属性定义
  - 继承属性依赖父结点，或左兄弟结点
- 语法制导定义/翻译模式的设计

### 综合属性、继承属性

描述文法符号——③综合属性 ④继承属性

- 综合属性值的计算依赖于分析树中他的子节点的属性值
- 继承属性值的计算依赖于分析树中他的父节点的属性值

**语法制导定义形式：**

<img src=".\pic\image-20250105214411391.png" alt="image-20250105214411391" style="zoom:50%;" />

<img src=".\pic\image-20250105214543234.png" alt="image-20250105214543234" style="zoom:50%;" />

S属性就是只有综合属性，语法树自底向上进行计算

<img src=".\pic\image-20250105215024117.png" alt="image-20250105215024117" style="zoom:50%;" />

继承属性：就是自上到下的推导

<img src=".\pic\image-20250105215203728.png" alt="image-20250105215203728" style="zoom:50%;" />

依赖图就是，属性b如果依赖属性a的话，那么属性b应该在a之后进行计算

<img src=".\pic\image-20250105215329718.png" alt="image-20250105215329718" style="zoom:50%;" />

将语法树进行压缩：

<img src=".\pic\image-20250105215738368.png" alt="image-20250105215738368" style="zoom:50%;" />

表达式语法树的构造：

<img src=".\pic\image-20250105215829335.png" alt="image-20250105215829335" style="zoom:50%;" />

类似于后缀形式

辅助函数：

<img src=".\pic\image-20250105215927374.png" alt="image-20250105215927374" style="zoom:50%;" />

举个例子：

<img src=".\pic\image-20250105220151901.png" alt="image-20250105220151901" style="zoom:50%;" />

对应的语法制导定义：

<img src=".\pic\image-20250105220959237.png" alt="image-20250105220959237" style="zoom:50%;" />

S属性：综合属性，自下到上的分析，因此可以和LR(1)分析器相结合

L属性：语法分析同时进行翻译，深度优先的顺序进行属性的计算——适用于LL(1)文法

<img src=".\pic\image-20250105221340750.png" alt="image-20250105221340750" style="zoom:50%;" />

所有的S都是L！！！

<img src=".\pic\image-20250105221618192.png" alt="image-20250105221618192" style="zoom:50%;" />







> 例题：
>
> <img src=".\pic\image-20250105160610916.png" alt="image-20250105160610916" style="zoom:50%;" />
>
> 答案：
>
> ```
> R → char	{ R.p = mkleaf(char.lexme); }
> R → ' e '	{ R.p = mkleaf_epsilon(); }
> R → R­1 '|' R2 { R.p = mknode(UNION, R­1.p, R2.p); }
> R → R­1 . R2 { R.p = mknode(CON, R­1.p, R2.p); }
> R → R­1 * { R.p = mknode(CLOSOURE, R­1.p, NULL); }
> R → ( R­1 ) { R.p = R­1.p; }
> ```
>
> ![image-20250105200331068](.\pic\image-20250105200331068.png)
>
> ![image-20250105200504431](.\pic\image-20250105200504431.png)
>
> ![image-20250105200556110](.\pic\image-20250105200556110.png)
>
> ![image-20250105200642068](.\pic\image-20250105200642068.png)
>
> ![image-20250105201547939](.\pic\image-20250105201547939.png)
>
> ![image-20250105201626661](.\pic\image-20250105201626661.png)
>
> ![image-20250105201652542](.\pic\image-20250105201652542.png)
>
> ![image-20250105201739180](.\pic\image-20250105201739180.png)
>
> ![image-20250105202321811](.\pic\image-20250105202321811.png)
>
> ![image-20250105202521516](.\pic\image-20250105202521516.png)
>
> ![image-20250105202547651](.\pic\image-20250105202547651.png)
>
> ![image-20250106005638914](.\pic\image-20250106005638914.png)





## 第六章 类型检查

### 类型表达式

就是用来表达语言结构的类型的表达式

<img src=".\pic\image-20250105175704037.png" alt="image-20250105175704037" style="zoom:50%;" />

<img src=".\pic\image-20250105175719691.png" alt="image-20250105175719691" style="zoom:50%;" />

<img src=".\pic\image-20250105175738333.png" alt="image-20250105175738333" style="zoom: 50%;" />

<img src=".\pic\image-20250105175800932.png" alt="image-20250105175800932" style="zoom:50%;" />

<img src=".\pic\image-20250105175950997.png" alt="image-20250105175950997" style="zoom: 50%;" />

### 类型表达式等价

**两种等价：结构等价和名字等价**

结构等价：

<img src=".\pic\image-20250105180115906.png" alt="image-20250105180115906" style="zoom:50%;" />

<img src=".\pic\image-20250105180131744.png" alt="image-20250105180131744" style="zoom:50%;" />



<img src=".\pic\image-20250105180222052.png" alt="image-20250105180222052" style="zoom: 50%;" />

名字等价：

<img src=".\pic\image-20250105180301450.png" alt="image-20250105180301450" style="zoom:50%;" />

- 名字等价：类型表达式完全相同
- 结构等价：类型名被替换之后完全相同

<img src=".\pic\image-20250105180422128.png" alt="image-20250105180422128" style="zoom:50%;" />

- C——对函数结构等价。**对struct名字等价。**对record也是名字等价

- Pascal——默认名字等价。
- 也就是说，对于struct来说，C和pascal都是名字等价的

<img src=".\pic\image-20250105180705828.png" alt="image-20250105180705828" style="zoom:50%;" />





## 第七章 运行时环境

考试要求：

<img src=".\pic\image-20250105182447486.png" alt="image-20250105182447486" style="zoom:50%;" />

### 内存分配策略

<img src=".\pic\image-20250105182526568.png" alt="image-20250105182526568" style="zoom:50%;" />

静态分配：不允许递归，不允许动态的数据分配

<img src=".\pic\image-20250105182557308.png" alt="image-20250105182557308" style="zoom:50%;" />

栈分配：

<img src=".\pic\image-20250105182643852.png" alt="image-20250105182643852" style="zoom:50%;" />

注意变量的作用域问题

<img src=".\pic\image-20250105183624892.png" alt="image-20250105183624892" style="zoom:50%;" />

### 参数传递

#### 传值方式

<img src=".\pic\image-20250105183735580.png" alt="image-20250105183735580" style="zoom:50%;" />

传递的例子：

<img src=".\pic\image-20250105183815308.png" alt="image-20250105183815308" style="zoom:50%;" />

对形参的操作不会影响实参的值，也就是说，调用者存储空间中的数据发生变化，是不会影响主存储空间中的数据的

也可以通过传递指针来改变实参的值！！！

<img src=".\pic\image-20250105183954494.png" alt="image-20250105183954494" style="zoom:50%;" />

#### 传地址方式

还可以隐式传参：

<img src=".\pic\image-20250105184028347.png" alt="image-20250105184028347" style="zoom:50%;" />

<img src=".\pic\image-20250105184611206.png" alt="image-20250105184611206" style="zoom:50%;" />

<img src=".\pic\image-20250105184629745.png" alt="image-20250105184629745" style="zoom:50%;" />

#### 复制-恢复方式

<img src=".\pic\image-20250105184652520.png" alt="image-20250105184652520" style="zoom:50%;" />

<img src=".\pic\image-20250105184705052.png" alt="image-20250105184705052" style="zoom:50%;" />

#### 传名方式

<img src=".\pic\image-20250105184727959.png" alt="image-20250105184727959" style="zoom: 50%;" />

<img src=".\pic\image-20250105184752464.png" alt="image-20250105184752464" style="zoom: 50%;" />



## 第八章 中间代码生成

考试要求：

<img src=".\pic\image-20250105184937591.png" alt="image-20250105184937591" style="zoom:50%;" />

### 三地址码

<img src=".\pic\image-20250105185305151.png" alt="image-20250105185305151" style="zoom:50%;" />

语句类型：

<img src=".\pic\image-20250105185332641.png" alt="image-20250105185332641" style="zoom: 50%;" />



homework：

![image-20250105193420297](.\pic\image-20250105193420297.png)



### 表达式翻译

临时变量重用

<img src=".\pic\image-20250105185501640.png" alt="image-20250105185501640" style="zoom: 50%;" />

<img src=".\pic\image-20250105185601170.png" alt="image-20250105185601170" style="zoom:50%;" />



### 布尔表达式和控制流语句翻译

<img src=".\pic\image-20250105185850555.png" alt="image-20250105185850555" style="zoom:50%;" />

综合：

<img src=".\pic\image-20250105190040868.png" alt="image-20250105190040868" style="zoom:50%;" />

例子：

<img src=".\pic\image-20250105190156342.png" alt="image-20250105190156342" style="zoom:67%;" />

我们首先得清楚运算的顺序：

先是计算最右边的两个加法，然后再加，再乘，到这里都只需要使用一个临时变量。然后左边的和右边的相加需要使用一个临时变量，所以一共是两个





## 第九章 目标代码生成

<img src=".\pic\image-20250105191043618.png" alt="image-20250105191043618" style="zoom:50%;" />

### 代码生成算法

<img src=".\pic\image-20250105192236666.png" alt="image-20250105192236666" style="zoom:50%;" />

### 寄存器分配

<img src=".\pic\image-20250105192625813.png" alt="image-20250105192625813" style="zoom:50%;" />

例子：

<img src=".\pic\image-20250105194049622.png" alt="image-20250105194049622" style="zoom:50%;" />

这题选



### DAG构造

<img src=".\pic\image-20250105195315435.png" alt="image-20250105195315435" style="zoom:50%;" />





## 第十章 代码优化

<img src=".\pic\image-20250105190418820.png" alt="image-20250105190418820" style="zoom: 33%;" />

在进行代码优化的时候，重点考虑**循环**结构。

基本块的定义：连续的语句序列，执行过程中没有分支

1. **基本块构建——找leader**

   * 程序第一条语句（看题目有没有提到程序
   * 无/有条件跳转**目的语句**
   * 无/有条件跳转**下一条语句**（容易忘！

   后面代码基本块不用显式构造 每个leader对应的基本块就是下一个leader或者是程序的尾部

2. **流图：前驱与后继**

   看一个基本块最后一个语句：

   <img src=".\pic\image-20250105191635584.png" alt="image-20250105191635584" style="zoom:50%;" />

   * 有 有/无条件跳转到B2——B2（可能是false分支的无条件跳转）1
   * 无 有/无条件跳转，紧跟B3——B3

   后面代码基本块通过goto Lnext语句**指向空气即可。**

3. **循环：**

   * 这组节点是**强连通的**（任何两个节点之间都存在一条完全包含在循环内的路径）
   * 这组节点具有**唯一的一个入口（entry）**——从循环外的节点到达循环内的节点，**唯一的途径是先到达入口节点**

4. **下次引用：从后往前扫描。**

   遇到指令i，x=y op z：

   * 在指令后加入引用信息（使用/引用(use）：语句i赋值x，j以x作为运算对象，**且i到j**无其他赋值语句）
   * x非活跃，无下次引用
   * y活跃，有下次引用为i

   后两步不可以交换。最后得到临时变量生存周期。数据流分析）临时变量名字的重用与存储分配。嵌套不可以，一上一下可以。

5. **基本优化方法(global与local)：**

   * 消去公共子表达式（local）：要求两个重复的表达式之间没有对operand的定义（再赋值）。

     * <img src=".\pic\image-20250105192732297.png" alt="image-20250105192732297" style="zoom:50%;" />

   * 复制传播：

     * <img src=".\pic\image-20250105192820832.png" alt="image-20250105192820832" style="zoom:50%;" />
     * 单路径传播：直接利用复制的源头（赋值语句的源头，即赋值语句的右式）
     * 多路径传播：两个路径有相同右式的赋值表达式。不管从哪个路径来，用同一个临时变量代替。

   * 无用代码删除：

   * <img src=".\pic\image-20250105192930922.png" alt="image-20250105192930922" style="zoom:50%;" />

     利用复制传播，把变量直接替换为源头的常量（debug->false，也就做常量合并）。之后可以删除一些语句（源头的赋值语句，或者if(false)语句）

   * **==循环优化：==**

     * **代码外提：提至循环外。**

     * <img src=".\pic\image-20250105193010146.png" alt="image-20250105193010146" style="zoom:50%;" />

       某些代码（表达式计算）与循环次数无关【**或者说做的是相同的赋值操作**】，即循环不变计算。

       或者**和循环条件有关的变量在循环内部没有对其的定义（赋值运算）——>循环不变计算。**

       eg.**while(t<=limit-2)**

       从循环内提到循环入口前。具体而言，**提到一个前驱自定义基本块中。**

     * **强度削弱：**与i, j, k多有关。**乘方＞乘除＞加减。**

     * <img src=".\pic\image-20250105193057635.png" alt="image-20250105193057635" style="zoom:50%;" />

       同步变化的归纳变量，**记住可能要多加使用某个归纳变量的赋值。**

       eg.**j = j - 1 ; t4 = 4 * j ---> t4 = 4 * j ; j = j - 1 ; t4 = t4 - 4；**

     * **归纳变量删除：**归纳变量即i, j, k。

     * <img src=".\pic\image-20250105193118760.png" alt="image-20250105193118760" style="zoom:50%;" />

       * 如果前面有归纳变量给临时变量的赋值，则用临时变量替换。（PPT）
       * 如果之前没有，新加入临时变量的赋值，必须能减少一些。

homework：

![image-20250105193258146](.\pic\image-20250105193258146.png)

得到结果：

<img src=".\pic\image-20250105193356322.png" alt="image-20250105193356322" style="zoom:50%;" />